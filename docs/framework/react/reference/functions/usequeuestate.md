---
id: useQueueState
title: useQueueState
---

<!-- DO NOT EDIT: this page is autogenerated from the type comments -->

# Function: useQueueState()

```ts
function useQueueState<TValue>(options): readonly [TValue[], {
  addItem: (item, position?) => boolean;
  clear: () => void;
  getAllItems: () => TValue[];
  getNextItem: (position?) => undefined | TValue;
  isEmpty: () => boolean;
  isFull: () => boolean;
  peek: (position?) => undefined | TValue;
  size: () => number;
 }]
```

Defined in: [react-pacer/src/queue/useQueueState.ts:43](https://github.com/TanStack/pacer/blob/main/packages/react-pacer/src/queue/useQueueState.ts#L43)

A React hook that creates a queue with managed state, combining React's useState with queuing functionality.
This hook provides both the current queue state and queue control methods.

The queue state is automatically updated whenever items are added, removed, or reordered in the queue.
All queue operations are reflected in the state array returned by the hook.

By default uses FIFO (First In First Out) behavior, but can be configured for LIFO
(Last In First Out) by specifying 'front' position when adding items.

The hook returns a tuple containing:
- The current queue state as an array
- The queue instance with methods for queue manipulation

## Type Parameters

â€¢ **TValue**

## Parameters

### options

`QueueOptions`\<`TValue`\> = `{}`

## Returns

readonly \[`TValue`[], \{
  `addItem`: (`item`, `position`?) => `boolean`;
  `clear`: () => `void`;
  `getAllItems`: () => `TValue`[];
  `getNextItem`: (`position`?) => `undefined` \| `TValue`;
  `isEmpty`: () => `boolean`;
  `isFull`: () => `boolean`;
  `peek`: (`position`?) => `undefined` \| `TValue`;
  `size`: () => `number`;
 \}\]

## Example

```tsx
// Basic FIFO queue with state management
const [items, queue] = useQueueState({
  initialItems: ['item1', 'item2'],
  maxSize: 10,
  getPriority: (item) => item.priority
});

// Add items to queue
const handleAdd = (item) => {
  queue.addItem(item);
};

// Process items from queue
const handleProcess = () => {
  const nextItem = queue.getNextItem();
  if (nextItem) {
    processItem(nextItem);
  }
};
```
