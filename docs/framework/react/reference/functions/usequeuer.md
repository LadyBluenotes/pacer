---
id: useQueuer
title: useQueuer
---

<!-- DO NOT EDIT: this page is autogenerated from the type comments -->

# Function: useQueuer()

```ts
function useQueuer<TValue>(options): object
```

Defined in: [react-pacer/src/queuer/useQueuer.ts:48](https://github.com/TanStack/bouncer/blob/main/packages/react-pacer/src/queuer/useQueuer.ts#L48)

A React hook that creates and manages a Queuer instance.

This is a lower-level hook that provides direct access to the Queuer's functionality without
any built-in state management. This allows you to integrate it with any state management solution
you prefer (useState, Redux, Zustand, etc.) by utilizing the onUpdate callback.

For a hook with built-in state management, see useQueuerState.

The Queuer extends the base Queue to add processing capabilities. Items are processed
synchronously in order, with optional delays between processing each item. The queuer includes
an internal tick mechanism that can be started and stopped, making it useful as a scheduler.
When started, it will process one item per tick, with an optional wait time between ticks.

By default uses FIFO (First In First Out) behavior, but can be configured for LIFO
(Last In First Out) by specifying 'front' position when adding items.

## Type Parameters

â€¢ **TValue**

The type of items stored and processed by the queue

## Parameters

### options

`QueuerOptions`\<`TValue`\>

Configuration options including started (whether to begin processing immediately),
               wait time between processing items, getPriority for ordering items, and more.

## Returns

`object`

An object containing queue control methods

### addItem()

```ts
addItem: (item, position?) => boolean;
```

Adds an item to the queue and starts processing if not already running

#### Parameters

##### item

`TValue`

The item to add

##### position?

The position to add the item to (defaults to back for FIFO behavior)

`"front"` | `"back"`

#### Returns

`boolean`

true if item was added, false if queue is full

### clear()

```ts
clear: () => void;
```

Removes all items from the queue

#### Returns

`void`

### getAllItems()

```ts
getAllItems: () => TValue[];
```

Returns a copy of all items in the queue

#### Returns

`TValue`[]

### getExecutionCount()

```ts
getExecutionCount: () => number;
```

Returns the number of items that have been removed from the queue

#### Returns

`number`

### getNextItem()

```ts
getNextItem: (position?) => undefined | TValue;
```

Removes and returns an item from the queue using shift (default) or pop

#### Parameters

##### position?

`QueuePosition`

Where to remove the item from (defaults to front for standard FIFO behavior)

#### Returns

`undefined` \| `TValue`

the removed item or undefined if empty

Examples:
```ts
// Standard FIFO queue
queue.getNextItem()
// Stack-like behavior (LIFO)
queue.getNextItem('back')
```

### isEmpty()

```ts
isEmpty: () => boolean;
```

Returns true if the queue is empty

#### Returns

`boolean`

### isFull()

```ts
isFull: () => boolean;
```

Returns true if the queue is full

#### Returns

`boolean`

### isIdle()

```ts
isIdle: () => boolean;
```

Returns true if the queuer is running but has no items to process

#### Returns

`boolean`

### isRunning()

```ts
isRunning: () => boolean;
```

Returns true if the queuer is running

#### Returns

`boolean`

### onUpdate()

```ts
onUpdate: (cb) => () => void;
```

Adds a callback to be called when an item is processed

#### Parameters

##### cb

(`item`) => `void`

The callback to add

#### Returns

`Function`

A function to remove the callback

##### Returns

`void`

### peek()

```ts
peek: (position?) => undefined | TValue;
```

Returns an item without removing it

#### Parameters

##### position?

`QueuePosition`

Which item to peek at (defaults to front for standard FIFO behavior)

Examples:
```ts
// Look at next item to getNextItem
queue.peek()
// Look at last item (like stack top)
queue.peek('back')
```

#### Returns

`undefined` \| `TValue`

### reset()

```ts
reset: (withInitialItems?) => void;
```

Resets the queue to its initial state

#### Parameters

##### withInitialItems?

`boolean`

#### Returns

`void`

### size()

```ts
size: () => number;
```

Returns the current size of the queue

#### Returns

`number`

### start()

```ts
start: () => void;
```

Starts the queuer and processes items

#### Returns

`void`

### stop()

```ts
stop: () => void;
```

Stops the queuer from processing items

#### Returns

`void`

## Example

```tsx
// Example with custom state management and scheduling
const [items, setItems] = useState([]);

const queue = useQueuer({
  started: true, // Start processing immediately
  wait: 1000,    // Process one item every second
  onUpdate: (queue) => setItems(queue.getAllItems()),
  getPriority: (item) => item.priority // Process higher priority items first
});

// Add items to process - they'll be handled automatically
queue.addItem('task1');
queue.addItem('task2');

// Control the scheduler
queue.stop();  // Pause processing
queue.start(); // Resume processing
```
